// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

int numberofParticles;
float G;
float3 netField = 0;

struct Particle
{
    float3 position;
    float mass;
};

RWStructuredBuffer<Particle> particles; //Particle data sent from CPU
RWStructuredBuffer<float3> output; //net force on each particle sent back to CPU

//Calculate the total gravitational force on each particle from every other particle
[numthreads(32,32,1)] //numthreads(32,32,1) with workgroups (Num/1024,Num/1024,1) seems to work best
void CSMain (uint3 id : SV_DispatchThreadID)
{
    int bufferID = id.x + 32*(id.y + 1*id.z); //"flatten" 3D array indices to 1D: [x,y,z] = x + d*y + d*h*z (h = height [size of array in y], d = depth [size of array in z])
    Particle thisParticle = particles[bufferID]; //get the 'i'th particle in the buffer

    for(int j = 0; j < numberofParticles; j++)
    {
        float3 dist = particles[j].position - thisParticle.position;
        float3 dir = normalize(dist);
        float3 invSqr = dir / (dot(dist,dist));

        if(j != bufferID)//ensures we dont get the force of a particle on itself (infinity)
        {
            netField += particles[j].mass*invSqr; // F = G M m / r^2, G is stored in CPU, m is mass of the jth partcile, 
                                                                    //  m /r^2 is done in this line, which makes this a gravitational field rather than a force
        }

    }
    /*for(int j = 0; j < numberofParticles ; j++)//grav force is symmetric: F_12 = -F_21 -- should be able to half the number of evaluations?
    {
        if(thisParticle.position.x != particles[j].position.x || thisParticle.position.y != particles[j].position.y || thisParticle.position.z != particles[j].position.z) //ensures we dont get the force of a particle on itself (infinity)
        {
            float3 dist = particles[j].position - thisParticle.position;
            float3 dir = normalize(dist);
            float3 invSqr = dir / (dot(dist,dist)) ;
            output[bufferID] += particles[j].mass*invSqr; // F = G M m / r^2, G is stored in CPU, m is mass of the jth partcile, 
                                                                    //  m /r^2 is done in this line, which makes this a gravitational field rather than a force
            if(j == bufferID)
            {

            }
            else
            {
                output[j] += -thisParticle.mass*invSqr;
            }
        }

    }*/
    output[bufferID] =  G*thisParticle.mass*netField; // F = G M m / r^2, multiplying by M turns the field into a force
}
